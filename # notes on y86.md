# y86系统

## 4.1.1
- 15个寄存器：%rsp作为栈指针
- 3个1位条件码
- 内存是一个很大的字节数组
- 状态码

##4.1.2 Y86-64指令
- 仅包含8字节整数操作，称为字

指令集：
- movq：irmovq, rrmovq, mrmovq, rmmovq。
- 操作指令：addq, subq, andq, xorq。
	- 会设置条件码
	- 仅对寄存器工作
- 跳转指令：jmp, jle, jl, je, jne, jge, jne, jg。
- 条件传送指令：comvle, cmovl, cmove, comvne, comvge, comvq。
- call：压入返回地址，跳到目的地址
- ret：跳到返回地址
- pushq, popq：出栈，入栈
- halt：指令停止

![Snipaste_2018-11-05_13-07-32](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_13-07-32.png)

##4.1.3指令编码
- 每条指令1~10个字节。
- 第一个字节用来指示指令类型，该字节分为两部分，每部分四位，高四位为代码（0~0xB）、低四位为功能

![Snipaste_2018-11-05_10-53-48](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_10-53-48.png)

- 十五个寄存器分别对应一个标识符（0~0xE），使用0xF表示不需要访问寄存器。对于只需要一个指示符的，将另一个写为0xF。对于call等指令就没有这一个字节。

e.g.一个编码的例子：
rmmovq %rsp,0x12345678abcd(%rdx)，第一个字节：40，表示rmmvq，第二个字节42，表示%rsp和%rdx，最后在0x123456789abcd前填充0，使得其为8个字节：00 01 23 45 67 89 ab cd，然后使用小端法储存：cd ab 89 67 45 34 23 01 00。这样的结果是：4042cdab896745230100。

- Y86-64有条件码、长度可变的指令，并用栈保存返回地址。通过寄存器传递参数。

##4.1.4 Y86-64异常
程序员可见的stat码，表示的是程序运行的状态。

![Snipaste_2018-11-05_12-31-09](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_12-31-09.png)

> 异常处理程序？

- Y86的一个特性：他不可以直接使用立即数进行运算而是要想把他弄到寄存器中。

##4.1.6 一些指令的详情

- pushq指令会把rsp压进栈里，然后再移动rsp的位置

#4.3 Y86的顺序实现
##4.3.1
几个阶段：

- 取指（fetch）:获取指令字节，地址为程序计数器的PC值。分为icode和ifun。他计算出PC的值加上这个已取出的指令的值。valP等于PC的值加上已经取出的指令长度。
- 译码（decode）：从寄存器文件读入两个操作数，得到valA&valB
- 执行（execute）：要么执行知名操作，计算引用地址，要么改变栈指针。得到valE。同时设置条件码。
- 访存（memory）：将数据写入内存，或者从内存中读取数据。valM。
- 写回（write back）：写两个结果到寄存器。
- 更新PC（PC update）：将PC设置成下一条指令的地址。

![Snipaste_2018-11-05_13-18-55](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_13-18-55.png)

为了更好的理解：

![Snipaste_2018-11-05_14-35-22](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-35-22.png)

![Snipaste_2018-11-05_14-38-32](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-38-32.png)

![Snipaste_2018-11-05_14-39-00](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-39-00.png)

以上的更多解释可以在p304看见（电子版的）

![Snipaste_2018-11-05_14-47-36](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-47-36.png)

##4.3.2 SEQ硬件结构

一个结构图：

![Snipaste_2018-11-05_15-03-44](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_15-03-44.png)

硬件与各个阶段之间的关联：
- 取值：读取指令的字节，PC增加器计算新的valP
- 译码：同时读取寄存器值
- 执行：ALU。执行指定的运算。作为一个加法器做加值处理。同时计算出新的条件码。
- 访存：读出或者写入一个内存字。
- 写回：端口E写ALU计算出的值，端口M写从内存中读出来的值。
- PC更新：下一个指令valC，调用指令或者跳转指令使用valM的值。

一张更详细的图：

![Snipaste_2018-11-05_15-14-34](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_15-14-34.png)

现在进行到p310了

##4.3.4 SEQ的阶段实现
###取指阶段
以PC作为第一个字节的地址。

##4.4流水线通用原理


## 4.5 Y86的流水实现

### PC的选择

将上一次的信息记录在一个寄存器中。开始时先进行PC的计算然后再开始流程。

### 4.5.2 流水线寄存器

每一个阶段有流水线寄存器进行分隔。流水线寄存器的标号方式：

- F：程序计数器的预测值
- D：取指与译码之间，保存取指的信息
- E：译码与执行之间，保存从寄存器文件中获得的值
- M：执行与访存之间，保存最新的指令执行结果。保存Cnd
- W：反馈路径算出的值，向PC提供逻辑选择。

### 4.5.3 对信号重新排列

命名机制：

- 信号名前加入大写字母作为前缀。
- 对于刚计算出来的值以小写字母作为前缀。
- 大写的字母保存的是一个状态，而小写字母是一个过程
- 译码阶段dstE指明valE的目的寄存器

SelectA块：
将call,jxx中的valP的值作为valA信号传递，以减少寄存器的数量。状态码随指令一起流通过流水线。

### 4.5.4 预测下一个PC

每一个时钟周期必定意味着一个指令的读入，但是有的指令不可以很快获得 ，所以需要做一个预测。

对于call和jmp来说，下一个指令就是常数值，其他指令是valP。对于条件转移来说，我们可以做出一个估计：从valC与valP中选择一个。但是我们将预测一定跳转。ret指令则不做预测。取指阶段负责预测下一个PC值，这个值会从valP和valC中选择一个，并存储在寄存器F中。SelectPC会从三个值中选择一个作为指令内存地址：预测的PC，ret到达流水寄存器W的返回地址值，到达流水寄存器M的不选择分支valP的值。

### 4.5.5 流水线冒险

- 数据相关-数据冒险
- 控制相关-控制冒险

技术：

1. 使用暂停来避免数据冒险。
   1. 让一条指令停留在译码阶段，直到需要这个暂停的操作通过了写回阶段。
2. 使用转发来避免数据冒险。
   1. 直接从流水线阶段传到更早的阶段的技术。
   2. 一共有的5个转发源：e_valE,m_valM,M_valE,W_valM,W_valE
   3. 两个转发目的地：valA, valB
3. 加载/使用数据冒险
   1. 将暂停与转发结合起来
   2. 插入一个气泡，这种方法称为加载互锁。
   3. 加载互锁足以解决所有的数据冒险



1. 控制冒险
   1. 控制冒险只会发生在jxx和ret
   2. 对于ret，在其进入写回阶段前，其余语句不可以做出任何动作。直接插入三个bubble。
   3. 对于jxx，在发现计算错误时已经读入了两个指令。此时我们需要在下一个周期往译码和执行阶段中插入气泡。并同时取出跳转的指令。

### 4.5.7 PIPE各阶段的实现

#### 1.PC选择和取指阶段

### 4.5.8 流水线控制逻辑

1. 特殊控制情况所期望的处理

   mrmovq和popq：当这两个指令中的一个处于执行阶段时，我们将第二个语句堵塞在译码阶段，并在下一个周期在执行阶段插入一个气泡。可以将D、F保持为固定状态。

   ret：流水线停顿三个周期。取指阶段会暂停三个时钟周期，导致不断取出下一个指令，但在译码阶段被替换为气泡。

   但jxx预测分支错误时：在jxx执行的下一个时钟周期将译码阶段以及执行阶段取出的指令改为气泡。

   异常状态的处理：我们什么也不干，知道异常状态码进入访存阶段，当异常发生时，我们采取措施：

    	1. 禁止执行阶段修改条件码
    	2. 向内存阶段插入气泡
    	3. 写回阶段暂停写回，从而暂停流水线

2. 发现特殊控制条件

   出现三种特殊情况的方式时通过组合逻辑得到，并且在下一个时中周期沿到达前得到结论（即是本阶段的最后一个操作）。

3. 流水线控制机制

   一些低级的控制逻辑使得指令可以阻塞或者添加一个气泡。

   每一个流水寄存器有两个控制输入，一个是stall，另一个是bubble。正常情况下这两个都设置为零。

   当stall为1的时候，它会保存之前的状态，即是说跳过更新。当bubble为1的时候，寄存器获得一个等效于nop的状态。

   一个例子：若要往流水寄存器D抽入一个bubble，则仅需要将其icode改为INOP

4. 控制条件的组合

5. 控制逻辑的实现

