# y86系统

## 4.1.1
- 15个寄存器：%rsp作为栈指针
- 3个1位条件码
- 内存是一个很大的字节数组
- 状态码

##4.1.2 Y86-64指令
- 仅包含8字节整数操作，称为字

指令集：
- movq：irmovq, rrmovq, mrmovq, rmmovq。
- 操作指令：addq, subq, andq, xorq。
	- 会设置条件码
	- 仅对寄存器工作
- 跳转指令：jmp, jle, jl, je, jne, jge, jne, jg。
- 条件传送指令：comvle, cmovl, cmove, comvne, comvge, comvq。
- call：压入返回地址，跳到目的地址
- ret：跳到返回地址
- pushq, popq：出栈，入栈
- halt：指令停止

![Snipaste_2018-11-05_13-07-32](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_13-07-32.png)

##4.1.3指令编码
- 每条指令1~10个字节。
- 第一个字节用来指示指令类型，该字节分为两部分，每部分四位，高四位为代码（0~0xB）、低四位为功能

![Snipaste_2018-11-05_10-53-48](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_10-53-48.png)

- 十五个寄存器分别对应一个标识符（0~0xE），使用0xF表示不需要访问寄存器。对于只需要一个指示符的，将另一个写为0xF。对于call等指令就没有这一个字节。

e.g.一个编码的例子：
rmmovq %rsp,0x12345678abcd(%rdx)，第一个字节：40，表示rmmvq，第二个字节42，表示%rsp和%rdx，最后在0x123456789abcd前填充0，使得其为8个字节：00 01 23 45 67 89 ab cd，然后使用小端法储存：cd ab 89 67 45 34 23 01 00。这样的结果是：4042cdab896745230100。

- Y86-64有条件码、长度可变的指令，并用栈保存返回地址。通过寄存器传递参数。

##4.1.4 Y86-64异常
程序员可见的stat码，表示的是程序运行的状态。

![Snipaste_2018-11-05_12-31-09](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_12-31-09.png)

> 异常处理程序？

- Y86的一个特性：他不可以直接使用立即数进行运算而是要想把他弄到寄存器中。

##4.1.6 一些指令的详情

- pushq指令会把rsp压进栈里，然后再移动rsp的位置

#4.3 Y86的顺序实现
##4.3.1
几个阶段：

- 取指（fetch）:获取指令字节，地址为程序计数器的PC值。分为icode和ifun。他计算出PC的值加上这个已取出的指令的值。valP等于PC的值加上已经取出的指令长度。
- 译码（decode）：从寄存器文件读入两个操作数，得到valA&valB
- 执行（execute）：要么执行知名操作，计算引用地址，要么改变栈指针。得到valE。同时设置条件码。
- 访存（memory）：将数据写入内存，或者从内存中读取数据。valM。
- 写回（write back）：写两个结果到寄存器。
- 更新PC（PC update）：将PC设置成下一条指令的地址。

![Snipaste_2018-11-05_13-18-55](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_13-18-55.png)

为了更好的理解：

![Snipaste_2018-11-05_14-35-22](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-35-22.png)

![Snipaste_2018-11-05_14-38-32](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-38-32.png)

![Snipaste_2018-11-05_14-39-00](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-39-00.png)

以上的更多解释可以在p304看见（电子版的）

![Snipaste_2018-11-05_14-47-36](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_14-47-36.png)

##4.3.2 SEQ硬件结构

一个结构图：

![Snipaste_2018-11-05_15-03-44](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_15-03-44.png)

硬件与各个阶段之间的关联：
- 取值：读取指令的字节，PC增加器计算新的valP
- 译码：同时读取寄存器值
- 执行：ALU。执行指定的运算。作为一个加法器做加值处理。同时计算出新的条件码。
- 访存：读出或者写入一个内存字。
- 写回：端口E写ALU计算出的值，端口M写从内存中读出来的值。
- PC更新：下一个指令valC，调用指令或者跳转指令使用valM的值。

一张更详细的图：

![Snipaste_2018-11-05_15-14-34](C:\Users\13808\Documents\Joseph\CSFolder\ics作业\pj\图片\Snipaste_2018-11-05_15-14-34.png)

现在进行到p310了

##4.3.4 SEQ的阶段实现
###取指阶段
以PC作为第一个字节的地址。

##4.4流水线通用原理


## 4.5 Y86的流水实现

### PC的选择

将上一次的信息记录在一个寄存器中。开始时先进行PC的计算然后再开始流程。

### 4.5.2 流水线寄存器

每一个阶段有流水线寄存器进行分隔。流水线寄存器的标号方式：

- F：程序计数器的预测值
- D：取指与译码之间，保存取指的信息
- E：译码与执行之间，保存从寄存器文件中获得的值
- M：执行与访存之间，保存最新的指令执行结果。保存Cnd
- W：反馈路径算出的值，向PC提供逻辑选择。

### 4.5.3 对信号重新排列

命名机制：

- 信号名前加入大写字母作为前缀。
- 对于刚计算出来的值以小写字母作为前缀。
- 大写的字母保存的是一个状态，而小写字母是一个过程
- 译码阶段dstE指明valE的目的寄存器

SelectA块：
将call,jxx中的valP的值作为valA信号传递，以减少寄存器的数量。状态码随指令一起流通过流水线。

### 4.5.4 预测下一个PC

每一个时钟周期必定意味着一个指令的读入，但是有的指令不可以很快获得 ，所以需要做一个预测。

对于call和jmp来说，下一个指令就是常数值，其他指令是valP。对于条件转移来说，我们可以做出一个估计：从valC与valP中选择一个。但是我们将预测一定跳转。ret指令则不做预测。取指阶段负责预测下一个PC值，这个值会从valP和valC中选择一个，并存储在寄存器F中。SelectPC会从三个值中选择一个作为指令内存地址：预测的PC，ret到达流水寄存器W的返回地址值，到达流水寄存器M的不选择分支valP的值。

### 4.5.5 流水线冒险

- 数据相关-数据冒险
- 控制相关-控制冒险

技术：

1. 使用暂停来避免数据冒险。
   1. 让一条指令停留在译码阶段，直到需要这个暂停的操作通过了写回阶段。
2. 使用转发来避免数据冒险。
   1. 直接从流水线阶段传到更早的阶段的技术。
   2. 一共有的5个转发源：e_valE,m_valM,M_valE,W_valM,W_valE
   3. 两个转发目的地：valA, valB



