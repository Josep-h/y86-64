# 实验报告

by
​	解润芃&朱铭哲
​	id: 17307130196&17307130099	

---


## Introduction to y86 simulator version 2.0

y86模拟器第一版使用cpp作为底层文件，分为**界面板**与**终端版**。

**界面版**以UWP软件作为呈现方式，并且构建了基础的界面及其基础功能。使用细节见README.pdf

**终端版本**供一些其他调试使用。以“大黑框呈现”运行的结果。终端版本的使用操作在程序运行时会有提示。

---

## Some more details of the structure

### 硬件的模拟方法：

1. memory`(memory[])`：一个模拟以**字节**为单位（一个不超过0x200的数）的一个整形数组。在内存中，命令指令从0开始，RSP的值会被汇编码自动给定。在memory里面存储的所有数都是以字节的方式，每一个存入的数字默认为8字节。
2. register`(reg[])`：寄存器的模拟是以一个long long型的长为16数组的数组。其中存储的值具有正负号，并且是通过fetch阶段自动转成一个整型数。特殊的其中%reg为reg[4]，其余所有的值按照CSAPP上对于寄存器标号。
3. ALU：不对ALU模拟，直接使用逻辑运算，即“&”、“^”、“+”、“-”四个运算。
4. 流水线寄存器`freg,dreg,ereg,mreg,wreg`：流水线寄存器由几个特殊的封装类构成。其中保存的是流水线寄存器其应当保存的所有值，别无其他。
5. 线路上计算量`d,e,m,w`：线路计算量的值先保存在线路计算量中的值，以及从流水线寄存器获得的值。计算的结果值会在写入阶段进去流水线寄存器。
6. CC：CC值是由三个bool值，ZF，SF，OF保存。
7. 控制逻辑：对于bubble以及stall的控制保存在流水线寄存器freg,dreg,ereg,mreg,wreg中。
8. 其余如icode和ifun的表达形式延续CSAPP的中标号。
9. Cnd：在mreg类中保存寄存器中的Cnd，并且在计算临时量e中保存有Cnd。
10. Stat：最终的Stat值保存在Stat中，其他的状态量的stat保存在寄存器类中。
11. 组合逻辑：其余的组合逻辑使用直接的语句执行，如SelectPC等。
12. 一些标号：特殊状态值HLT，ADR，INS保持CSAPP上的标号，以及NONE也保持其上标号。
13. 引入cache机制的模拟以模仿高速缓存器的功能，高速缓存器是一个有8个set。为了方便易行，每个set仅有一个line，一次容纳8个byte。

### 流水线的实现（按照时间顺序）：

![all](C:\y86-64\y86_new\配图\all.png)

![run-in-cons](C:\y86-64\y86_new\配图\run-in-cons.png)

1. 先通过decoder函数把指令存在memory中。
2. SelectPC阶段：从predPC以及组合电路中接受一个新的PC值。
3. 取指阶段、译码阶段、执行阶段、访存阶段、写回阶段`run_in_cons()`：这是各计算量值的中间量计算过程，这一步不会写进流水线寄存器而是会等待在寄存器外部。也不会写进内存，Cnd会在被设置。
4. 转发阶段：通过计算量的结果进行转发，使满足条件的旧的数值更新。
5. 控制阶段：通过目前的计算量的中间量设置bubble和stall值，并且更改set_cc值。
6. 时间上升沿到达
7. 写入阶段：将流水寄存器更新，依照set_cc，bubble和stall，以及计算量的情况。
8. 重复以上过程直到出现错误状态我这HLT条件。
9. 输出结果，停机。

### 界面的实现

1. 使用xaml+c++，采用通用windows平台（uwp），但是第一版限于时间，并没注意体现uwp的特性，后期会进行修改。寄存器及运行量的值目前暂未采用十六进制表示，下一版将引入十六进制。内存的值暂时用十六进制表示。目前的内存仍是定格内存，下一个版本将增加可选内存观察的选项。

### 时光机的实现

![Cache](C:\y86-64\y86_new\配图\Cache.png)

1. 数据的存储：对于流水线寄存器和条件码，cache等硬件实施一个各自的栈用来保存每一步的操作。每一步操作开始之前存储当时的所有状态量。内存的储存通过识别内存是否被修改进行存储，并仅存储可能被修改的前一个量。
2. 数据的恢复：弹出栈顶值，并将里面的值赋给上述状态量来实现回归上一个状态。内存的操作类似。

---

## Some Highlights of Y86-simulator

1. 完成时光机的设计，可以任意查看任何时间的情况，包括内存以及寄存器中的值。可以随意地回退与前进，并直接到达任何一个循环。

2. cache机制的完成

---

## Process of implementation

### 分工

解润芃：y86内核部分，包括：y86流水线，cache机制，时光机。
朱铭哲：

### 内核部分总结：

耗时整整两个周末从开始写到调试全部完成。

使用C++实现，使用了C++STL中的stack库以完成时光机以及string以处理读入yo文件。内核部分差不多参照CSAPP上对于y86的实现，采用了一些数据结构和特殊执行顺序以模拟y86流水线寄存器值阻塞以及信号传递的问题。

实现的过程差不多是参照CSAPP流水线的建立过程写的，所以最开始建立简单的SEQ，然后加入流水线寄存器以及转发机制改为PIPE- ，最后加入流水线控制逻辑改为PIPE。

测试的过程从prog1开始，顺利地运行到prog5开始出现错误，于是开始逐步对照sim中PIPE的模拟结果寻找错误。其中夹杂逻辑错误，如Cnd的控制，以及各种各样的小错误。调试时间历时两天，但是在第一阶段结束时，输出没有全部转换十六进制，导致cmov的操作虽有一些问题，但是在测试时没有看出来，是的第一阶段的cmov样例有一些缺陷。该缺陷在测试更改输出方式时发现并修正。第一阶段结束。

第二阶段最开始完成输出的十六进制化，然后发现了cmov的问题，修正了cmov之后正式开始增加其他功能。

添加的第一个功能是时光机。因为日常单步调试时往往会因为自己错误按了一个按键而不得不从新开始运行程序，所以最希望加入的功能是后退，而既然后退实现了就可以连续后退，从而可以达到到达任何步骤的功能。时光机的实现策略有两个，一个是逐步实现，及运行一步保留一部的结果；或者直接运行完整个程序然后保留所有的数据实现前进后退，但是当时考虑到会实现在运行中临时修改一些值到期望值继续运行的功能，于是选择前者实现。

最后完成Cache机制的引入，Cache实现参照的就是高速缓存机制，没有特别的地方，cache会一次性从memory读入8个字节的值。因为cache机制的引入，时光机进行了一些细微的调整以判断存储的内存状态。

---


## Reference

CSAPP。
